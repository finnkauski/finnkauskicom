#+AUTHOR: Art
#+HUGO_BASE_DIR: .
#+HUGO_FRONT_MATTER_FORMAT: yaml
* Blog
** DONE Ramblings on style and pythonisms :python:programming:standards:@programming:@python:@opinion:
:PROPERTIES:
:AUTHOR: bob
:EXPORT_FILE_NAME: ramblings_on_style_and_pythonisms
:EXPORT_DATE: [2020-01-08 Wed 15:24]
:ID:       996d2c43-20f1-4b17-b1ff-7d324e01c15a
:END:
*** Motivation

#+begin_quote
If you get yourself into PEP8ing mode, what do you tend to see? You tend to see
the PEP8 stuff and not what really matters.

-- Raymond Hettinger, 2015
#+end_quote

Firstly, I am by no means a python expert, but I have been using =python= since
September 2015 (almost 4 years at the time of writing). In that time I've seen
numerous codebases written by people of varying ability and experience. I have
also worked in a development area which had a hard task of building
infrastructure for a massive organization.

As you use the language and hit your head into problem after problem, messy
codebase after messy codebase you start to wonder if there is some form of best
practice in writing consistent, clean and readable code.

Some of you probably have been in a position of looking back at a codebase you
wrote a while back and recoiling how untidy it is and how now you would `write
it in a much nicer way`. And to avoid this situation in the future, you might
have even jumped to your favorite search engine and tried looking for some
community driven standards. If you live in `python-land` you'll inevitably
stumble upon *PEP8*.

From here, you may go choose to go down one of two extreme routes:

1. *The Great Dictator*
   One of those people who are so militant about following this standard, that
   the ideology takes priority and it can impede long-term productivity. These
   people begin to demand more and more time allocated to nitpicking the
   smallest of issues never actually seeing the larger code issues that can
   hide within.

2. *The Dude/Dudette*
   Loves bowling, being a slacker. Hates having to do commenting, documenting code
   and sure as hell won't bother having nice versions control practices.
   Typically does what they want with a drink in their hand which might or might
   not contain a White Russian and when asked if they are aware of python coding
   standards they will just namedrop *PEP8* as if it was a junior python
   developer job interview and they want to hit the buzzword quota.

In my personal experience I've not met anyone on either of the two extremes.
Most people will end up between the two, even if nobody wants to admit that
they might be 1/5 dictator.

You /*should*/ read *PEP8*, internalize what you think will help you be clean and
consistent within you codebase and then just move on. The coding standard
quagmire is a hard one to navigate and it is why this write up essentially exists.
I'm here to try to encourage you to be more pragmatic and critical about coding
standards and to brain dump my thoughts on clean code in python.

*** Thoughts about PEP8
Ahh, =Python Enhancement Proposal number 8=, or *PEP8* for short. Created on
05-Jul-2001 to help establish a consistent way of styling your code. However in
my experience, it has been misused to great extent. You see, the issue here is that
people want nice and tidy python code, but by evangelically following this
standard and not compromising with *PEP8* they sometimes introduce other, more
glaring issues. Even *worse*, by reviewing other peoples code and focusing
purely on the compliance with PEP8, people miss what is known as /unpythonic/
code. In other words, code that can be made much tidier and clearer by
leveraging python specific language features.

Raymond Hettinger (python core developer) has a great talk (see [[https://www.youtube.com/watch?v=wf-BqAjZb8M][here]]) about
*PEP8* and how to write intelligible code. We will come back to some ideas
expressed in this talk throughoutour coverage of *PEP8*. But before moving on
I'd like raise a point that he makes early in the talk to set the scene:

#+BEGIN_QUOTE
What you want is that the people who are struggling a little bit (with a coding
problem) to overcome and deal with a problem and at some point become very
effective. How can you prevent that outcome. Its easy! You give them some low
hanging fruit, something to go do that seems productive but isn't. And one of
those things is a certain PEP, located between 7 and 9.
#+END_QUOTE

Also, I will be omitting quite a few guidelines as I cover *PEP8*, for the sake of
simplifying this writeup. By cherry-picking which ones to present, I will give
you fewer things to remember and more rule of thumb things to follow. Consider
this as me doing the hard work to suggest which are the most important parts.
You're welcome.

The one key message I want to get across before we proceed is that I do not
dislike *PEP8*. I think it's extremely useful, but I don't want people being
militant about following every bit of advice it gives without considering it for
their use case. Other than that I think everyone should read the PEP and
internalise what it tries to preach.


**** A note on Consistency

The first line of the PEP8 introduction states:

#+BEGIN_QUOTE
/This document gives conventions for the Python code comprising the
standard library in the main Python distribution./
#+END_QUOTE

The key word there is `convention` which is defined in the Oxford English
dictionary as: /A way in which something is usually done"/. The key word *there*
is /usually/. Consistency is important, but when consistency is not an option you
should use your best judgement. Knowing when to be inconsistent, comes with time and
experience so write code and get feedback.

As Mr. Hettinger says, a lot of people skip this part and jump further into
*PEP8*, but really this is a */key/* message across *PEP8*, know which battles to
fight and know which sacrifices to make to ensure consistency with PEP8
across your code-base and your project.

See [[https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds][here]] for yourself for a few cases where sacrificing style guide consistency
might be preferred.

**** Code Layout
****** Indentation
#+begin_quote
/Use 4 spaces for indentation./
#+end_quote

I firmly believe that using 4 spaced indents for your python code has a
significant impact on the readability of the code. Imagine having a piece of
code aligned as follows:

#+BEGIN_SRC python
def function(parameter):

  result = 0
  for i in parameter:
    if i > 10:
      result+=i
    else:
      continue

  return result
#+END_SRC

#+RESULTS:

I don't know about you, but to me this seems a bit cramped. Refactoring your
code as follows adds a bit more space and lets the eye clearly align and
distinguish what level each line is at. And yes, I know you can get indentation
guides in your fancy editor, but that won't be there for you when u want to
quickly open this in Notepad or view it on GitHub.

#+BEGIN_SRC python
def function(parameter):

    result = 0
    for i in parameter:
        if i > 10:
            result+=i
        else:
            continue

    return result
#+END_SRC

Note that things like the =if statement= and the code for each outcome is quite
clearly indented and at least to my eye is easier to split out!

The Indentation chapter of *PEP8* covers some more interesting choices for
indenting function parameters etc. If you are interested, you can read more
about it [[https://www.python.org/dev/peps/pep-0008/#code-lay-out][here]].

****** Tabs or Spaces?
#+begin_quote
/Spaces/
#+end_quote

I think as tedious as it sounds, you should use spaces (ideally 4) for
indentation. I think to make it simpler, a lot of modern text editors that are
used in coding as well as full blown [[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=3&cad=rja&uact=8&ved=2ahUKEwi1keyUr-niAhX_QxUIHR41DhUQFjACegQIEhAG&url=https%253A%252F%252Fen.wikipedia.org%252Fwiki%252FIntegrated_development_environment&usg=AOvVaw26G_hSQrwphgc0qRbOs_Ur][IDE]]'s will convert tabs into spaces for you
if you ask them to (if not by default).

The issue is that if you mix tabs and spaces (which might look the same to you,
but aren't really the same thing to python), you might get a *TabError* and that's
not something that you really want slowing you down when it is so easily avoidable.

****** Maximum Line Length
#+begin_quote
/PEP8 says 79. I say 90-ish/[fn:1]
#+end_quote

Hettinger raises a great point (which admittedly is reflected in PEP8 once you
read it more carefully) that militantly observing 79 character guidelines is
sometimes isn't very sensible.

*Indentation in python is important*. So lets say we have a bit of code with a
function and a few nested structures within the code. Something along the lines
of:

#+BEGIN_SRC python
def useful_function_name(list_of_entries, **kwargs):
    for list_of_subentries in list_of_entries:
        for subentry in list_of_subentries:
            if subentry not in some_global_list:
                print("{} is not in the global list".format(subentry))
            else:
                some_global_list.append(another_useful_function(subentry))
    return some_global_list
#+END_SRC

And perhaps you could say that this bit of code is not a realistic example, but
it serves to illustrate that by having descriptive variable and function names and
using 4 space indentation makes the 79 character limit approach ever so
quickly.

So where does this leave us. Well we could go away and make the names of the
functions and variables shorter, but we then sacrifice readability for some
arbitrary number of characters. But guess what? Nobody is going to force you
(although they could do it through [[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks][commit hooks]] and [[https://pypi.org/project/black/][black]]) to be consistent with
that number, which gives you the space really to set your own limits for your
own team.

Modern monitors and resolutions are wide. We can spare a few more characters
nowadays! However the key here is to keep the lines not too long and more
importantly readable. So pick a sensible line length (something like 90
characters perhaps just to add some space for indentation) and stick to it
unless you absolutely must deviate.

****** Blank Lines
I don't really have much to say on this bit of the style guide. I think it lays
out some sensible rules, but I do want to highlight this line:

#+begin_quote
Use blank lines in functions, sparingly, to indicate logical sections.
#+end_quote

I think this is a really good piece of advice and if you take away something
from this PEP8 suggestion on blank lines, it should probably be that.

****** Imports
#+begin_quote
- Imports are always put at the top of the file, just after any module comments
  and docstrings, and before module globals and constants
- Wildcard imports (from <module> import *) should be avoided
#+end_quote

Those 2 bits of advice I think are key, there are some other things you could
learn by reading that section, but those are really the key things to follow.

Imagine yourself opening a piece of code that someone else wrote. Now you scroll
through it without thinking, take a sip of coffee and start tackling the task of
understanding what it does. The first thing you want to know is what does it
depend on? What kind of packages do I need? Well if that person followed
sensible guidelines, you'd see it all in one place. Neat. On the other hand if
the imports are scattered everywhere, you need to do the good ol' =CTR+F= to
actually get what you want and even then it would involve tons of jumping around
through the file.

Imports at the top. Always.

Now the second bit of advice about imports with * is actually quite important. I
won't even go into things like namespacing, but suffice it to say that when one
reads through a codebase and stumbles upon a function that seems to be coming
from nowhere, usually * is to blame. And even worse if someone used two or
more * imports... well then you're in for a good ol' search online through the
package documentation (if you're lucky and that exists).

**** Pet Peeves and other recommendations

The [[https://www.python.org/dev/peps/pep-0008/#pet-peeves][pet peeves and other recommendations]] sections in PEP8 are quite sensible. I
would go check them out as they give you a better idea of the 'little things'
that you could do to make your code better.

**** Comments
#+begin_quote
Comments that contradict the code are worse than no comments. Always make a
priority of keeping the comments up-to-date when the code changes!
#+end_quote

Again, the section on comments is actually really good and has a ton of useful
content. However the highlighted bit there is really important. Keep your
comments (and [[https://www.geeksforgeeks.org/python-docstrings/][docstrings]] and any documentation) up to date!

Avoid inline comments that say what the code does explicitly. If your code looks
like this:
#+BEGIN_SRC python
validated_input = validate(some_text)
#+END_SRC

You don't need to comment it. It wastes your time, someone elses time
reading it, computers time, space, time, space-time...

Anyway, if you write your code in a tidy, descriptive way you won't need inline
comments that state what your code does. That said, a very sensible use-case for
an inline comment would be explaining why we are doing something and how it will
impact the outcome down the line. In the previous case there we could say:

#+BEGIN_SRC python
validated_input = validate(some_text) # Validate input to avoid code injection
#+END_SRC

**** Docstrings

This deserves its own writeup, but suffice it to say that there is a separate [[https://www.python.org/dev/peps/pep-0257][PEP]]
that covers how to style those. My advice on this account is: *USE THEM*. Please
go read about them, pick sensible guidelines on how to write them and use them.
Future you and anyone who reads your code will thank you.

I kept writing this post and decided to jump back up to this section and add a
bit more emphasis on docstring. I think once you've written them once or twice
given a chosen standard (I use the [[https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html][numpy]] standard) it will soon become almost
second nature. And it will *ALWAYS* be easier to write them straight after
you've written the code that they relate to. Because (a) you have all the things
it needs and does fresh in your head and (b) its much harder to not be
complacent with missing documentation when you know that it is code you've
written 3 months ago and it will be a faff figuring out what it does.

**** Naming conventions

There is a lot to talk about here. As the [[https://www.python.org/dev/peps/pep-0008/#descriptive-naming-styles][Descriptive: Naming Styles]] section of
*PEP8* shows, there are a lot of ways to name your functions, variables etc. I
personally use what is called snake case when I write in python meaning that I
link words in my function names with underscores like so:
#+BEGIN_SRC language
my_new_value = my_snake_case_function(old_value)
#+END_SRC

In python for the most part, that is the recommended way to name things like
variables and functions. In other languages, like =Rust=, you even get told off
by the compiler for not doing that. That said its not the end of the world to
use different conventions. I use CamelCase in =Haskell= for example as that is
loosely the standard in that language.

But even in python, you really have seperate conventions on what to name how.

Exception names, typing variables and class names make use of upper case and
capitalisation in python. And I think over time I realised that the naming
conventions for the various python objects actually sensible and readable.
The main reason that different types of objects have different styles is to make
it much easier, at a glance, to know something about what you are looking at. As
above, if you meet an object called =Guido= you know that it is a class of some
kind where `guido` would instead be a function, a variable or a module.

So not much to add here, go read that section and internalise that.

**** Programming Recommendations

Again, a great section. Well written, gives succinct and useful advice to people.
But more importantly it does a bit more than just tell you how to style your
code. It tells you how to write more /pythonic/ code (which is really sort of
the point of *PEP8* in a way).

It is not a tutorial on how to code in python, but it definitely introduces a
few concepts and how to use them in a sensible way to write more pythonic
looking and functioning code.

*** The shifting sands of simple

This section of the blog is a bit of

What does it mean to be /pythonic/?

Let me give you a few example functions:

#+BEGIN_SRC python
def example1():
    index = 0
    for color in ["yellow", "blue", "red"]:
        print(str(index) + " " + color)
        index = index + 1
# ------
def example2():
    for index, color in enumerate(["yellow", "blue", "red"]):
        print(f"{index + 1} {color}")

# ------ for fun :)
def example3():
    list(map(lambda tpl: print(f"{tpl[0]} {tpl[1]}"), enumerate(["yellow","blue","red"])))

#+END_SRC

Let's assume we don't care about efficiency in this function. We don't mind
because it does such a minor thing in the grand scheme of our codebase.
Under that assumption, both these functions will do the same job.

They should *not* fail or have different results unless people use old versions
of python, etc. But just by looking at them I can see which person has used python
more.

Now thats not to say that one is more right than another at this level, but
purely from the way they have written the piece of code its clear that
*example2* is leveraging a lot more of the python in-built tools than
*example1* (if something in there is new to you I hope you go and check it out).

`So what?` I can hear you say. Does that change much? Well as I am writing this
these two are equivilent to me, but the second one looks tidier as it leverages
things that are made to solve the required problems (like [[https://www.python.org/dev/peps/pep-0279/][enumerate]]). This is
what in my head it all boils down to. Over time you learn more about python, its
features and what should feel `right` when it comes to code in python. You
become more pythonic which to me means you start leveraging all the tools the
language has to offer in their intended use cases.

But whatever stage you are at, be it python wiz-kid, or just beginning with the
language, try appreciating the perspective of others. Wiz kids, appreciate that
sometime writing things out for others with more clear instructions could help
the target audience and junior devs get their heads around it more clearly
(*example1* is much easier to wrap your head around for someone new to python).

And the newbies, that are just discovering python, accept that some thing written
by people who have been doing it for a while will look much more concise and
sometimes will involve features you don't know about. But don't take this
sitting down, take the time when you can to look at these cryptic functions and
features, understand what *specific use case* they are trying to address and
incorporate them in your codebase.

So to sort of pull this all together, if you know about python and already write
pythonic code, think of who is going to read it and give them time to learn the
features of python. And if you're the *example1* person, take the time when you
see something come up that you haven't seen before to do a quick search online
and see if you can learn more about the language itself.

*** Solving things with dirty code

Now this is might be a contraversial section so I will keep it short. If you're
ever opening up a text file and want to get the last few lines or if you're just
opening a csv to save it to Excel, consider not worrying about code style at
all.

Hear me out. Learning how to write python code in a nice and tidy way takes
time. And if you're solving a one-off problem that will never see the light of
day and will sit in the depths of your =D:= drive, do it quick and simple. Dont
worry about variable names, line length, docstrings etc. Just do it and move on.

Over time as you write more and more public facing code you will internalise the
bits of *PEP8* you need and the next time you do the csv to Excel conversion (because
you lost the code in the cold depths of your hard drive), you will likely just
write it in a nice and tidy way without even noticing.

*** Conclusion
Reading back through the blog I realise there is a lot in here. And I really
want to perhaps stress 2 things from all of this:
- read the style guide, be critical and be disciplined
- take opportunities to write more code and learn more about =python= itself
  instead of focusing on line length

** TODO Journey through the web for Data Scientists
:PROPERTIES:
:EXPORT_FILE_NAME: journey-through-the-web-for-data-scientists
:EXPORT_DATE: [2020-02-12 Wed 20:00]
:END:

*** Intro
The tempo of these posts is going to escalate as I expect people to keep reading
more about the subject if they want to. This is mainly to keep me motivated to
write the content and for us to finish going through the good bits in good time.

This post will kick us off into this adventure by introducing the concepts of
HTML and CSS in as much depth as you need to know to follow along. I am not a
web developer so things like SCSS, React, Angular and so on are definitely out
of scope.

Anyway let's kick it off.

*** HTML

I won't cover the history of HTML, if you are interested in how it became what
it is now and where it all started read this [[https://www.wired.com/1997/04/a-brief-history-of-html/][great article by Wired]].

What we are concerned about today is what HTML is, how we can start using it and
where to find more information about. So let us follow that order in our
explanations.

**** What is it?

Basically, imagine you are writing on a piece of paper something along the lines
of a CV. Now you might want certain bits to stand out so you make the text
larger. In other cases you want to add bullet points so you start adding little
dots as you write down the list and so on.

Now as you write this down, instead of actually drawing (rendering) the text
larger or adding these bullet points, you could just tag each bit of text with a
flag saying: /"Oh, this is a bullet point"/ or /"Enlarge this heading"/.
Essentially instead of putting the work in drawing it out yourself, you are just
tagging bits of text with something that will tell however has to draw it out
(your browser) how to draw (render) the CV.

That fundamentally is whats called a /markup language/. There are many of them,
some less cluttered than others. But HTML is king and here are a few snippets of
it following along with out CV example:

#+BEGIN_SRC html
<h1>Jack Torrance</h1>

<h2>Skills and Expertise</h2>
<ul>
  <li>Caretaking</li>
  <li>Axes</li>
  <li>Writting</li>
</ul>
#+END_SRC

=<h1></h1>= and =<h2></h2>= are headings. =h1= is going to be rendered in larger
font and will be useful to make the name stand out. Similarly =h2= will also be
rendered with some emphasis, but it will be smaller than =h1=. You can go right
up to =h6=! Now, why are there two of them for every bit of text? Well as you
can see we need to tell the browser where one tag ends and where another tag
begins. Hence we call the tags that have =/= the closing tags.

Anyway, =ul= stands for unordered list and represents an unordered list, hence
the *ul* tag. =li= represents a list item, which once again is easy to remember
because of the name. Anyway, if you can imagine tables, horizontal parting lines
and so on these and many more are tags that you can put in your HTML. For a full
list of tags check out [[https://developer.mozilla.org/en-US/docs/Web/HTML/Element][this page here]].

One thing we haven't covered yet is that HTML in principle (as well as other
markup languages) are text. What I mean by that, is that when you look at HTML
you can read it and if you know all the tags you can likely imagine what it will
look like. So lets see what the html code above will look like if I incorporate
it in the blog:

-----
#+BEGIN_EXPORT html
<h1>Jack Torrance</h1>

<h2>Skills and Expertise</h2>
<ul>
  <li>Caretaking</li>
  <li>Axes</li>
  <li>Writting</li>
</ul>
#+END_EXPORT
-----
(note that I've added horizontal lines for separation)

So that is fundamentally what you need to know about HTML (at least
conceptually). If you want to be much more effective in HTML, you will need to
learn more about what tags are available ([[https://www.imdb.com/title/tt0081505/][here]]) and how to manipulate them.

***** The =<div>=

The one thing I still need to cover is the idea of nesting and the best and most
useful thing to show you in that respect is the =div= element (elements is what
we call parts of the page). The =div= crops up quite a lot and is basically a
content divider. Lets say I wanted to /group/ all the things we wrote about
skills. The best way to start is to /put it in a div/ like so:

#+BEGIN_SRC html
<h1>Jack Torrance</h1>

<div>
<h2>Skills and Expertise</h2>
<ul>
  <li>Caretaking</li>
  <li>Axes</li>
  <li>Writting</li>
</ul>
</div>
#+END_SRC

Why is this important? Well when we get to CSS and styling and layout, the
=<div>= will be one of the best tools in our arsenal to style and positions
things in chunks. Conceptually it will not be rendered to anything special, if I
showed you the page that comes out of the above HTML it would look the same as
before, but what changed is the grouping, which allows us to treat the skills
and experience list as one element. One can keep nesting with no issues which
will once again come into play soon.

***** Class and ID

So lets say you have two lists on our CV. One could refer to skills and
experience and the other perhaps to the educational background and past studies.
How do we conceptually differentiate these 2 lists?

To name individual elements of the HTML document we can give them a /unique/
name like so:

#+BEGIN_SRC html
<ul id="skills">
...
</ul>
<ul id="education">
...
</ul>
#+END_SRC

You can do this with the =<div>= element as well:

#+BEGIN_SRC html
<div id="skills">
<ul>
...
</ul>
</div>

<div id="education">
<ul>
...
</ul>
</div>
#+END_SRC

Now we can later (in CSS) refer to them as unique things. But what if we want to
group some elements into without putting them into a =<div>=? Here we stumble
upon the second naming tool - the class.

#+BEGIN_SRC html
<div id="skills">
<ul class="lists">
...
</ul>
</div>

<div id="education">
<ul class="lists">
...
</ul>
</div>
#+END_SRC

The distinction will become clearer later when we start looking at CSS, but
fundamentally the ids allow us to tag elements with a unique name whereas
classes allow us to group similar elements together.


**** Sidetrack: Editing HTML and CSS

As HTML (and CSS a we will soon find out) are just text documents, you can open
up anything that can edit text and start writing HTML or CSS. To illustrate lets
open the most basic text editing software you have. If you are on Windows open
up Notepad and copy in the HTML snippet of the CV we had above.

Save the text file as =index.html= (you don't have to name it like that but just
roll with it) and make sure that the operating system you are using hasn't added
things like =.txt= at the end (if it has, rename it to just =index.html=). If
you then open this file in the browser, you will see you HTML rendered on
screen. You can then edit the file, save, refresh the browser and bask in the
glory of the HTML you created.


*** CSS

Cascading Style Sheets. We got the point where we can add the content to the
page that we want by writing it in a text file and tagging bits with certain
tags. The next step is then to edit them to fit our creative vision.

There are several ways to do so and I will briefly fly through them from least
convenient (except for small tweaks) to most convenient (for larger projects).
** DONE Parser combinators :rust:haskell:programming:parsing:projects:@rust:@haskell:@projects
:PROPERTIES:
:EXPORT_FILE_NAME: parser-combinators
:EXPORT_DATE: [2020-06-17 Wed 10:36]
:ID:       6EBCAB26-E714-4BAC-AE17-BF562B87CBA4
:END:

*** Introduction

These are truly weird times. Those who are fortunate enough to have
spare time and not be troubled by the horrors and consequences of the pandemic
are be finding themselves spending a lot more time at home trying to occupy
themselves. What really resonated with me is this [[https://www.youtube.com/watch?v=snAhsXyO3Ck][great video]] by CGP Grey which
reminded me that we need to get out of this situation better than we went in (if
personal circumstances allow it).

Hobby projects are a great way to learn new skills and I always encourage all
the people I work with to keep building =STUFF= (but thats maybe just me being
[[https://www.youtube.com/watch?v=u6XAPnuFjJc][mastery driven]]).

This post will cover a recent project of mine on parser combinators which is a
hobby project that allowed me to learn stuff during lockdown.

*** Motivation

I spent some time learning Haskell a while back and one of the great pieces of
software written in Haskell is [[https://pandoc.org/][Pandoc]]. Pandoc is a file format converter
allowing you to convert files from one markup to another with ease[fn:markdown].

Pandoc (as far as I understand) uses _parser combinators_ to parse different
formats and convert them between each other. I saw this concept of parser
combinators also pop up in the [[https://haskellbook.com/][haskell book]] that I used to teach myself the
language. Lastly, it popped up as a video a while back in [[https://www.youtube.com/watch?v=N9RUqGYuGfw][Tsoding's video on
writing a JSON parser in 111 lines of haskell code]].

I finally caved and decided to write a simple scripting language (if you can
call it that) for scripting my lights[fn:lighthouse]. Check it out [[https://github.com/finnkauski/lightshow][here]].

Note that I will introduce the concepts, but I don't think I can teach and
provide in depth explanations for them. Mainly because I don't know them well
enough to do it justice. And also do keep in mind that there is probably a
parser combinator library in most languages (and if not, go write it) and you
will have to find that library yourself.

We won't be implementing parsers from scratch, if you are curious and want to
have a bash in implementing this from scratch, here are the 2 resources that I
followed along with that helped me:

1. [[https://bodil.lol/parser-combinators/][Learning Parser Combinators With Rust]]
2. [[https://www.youtube.com/watch?v=N9RUqGYuGfw][Tsodings JSON parser from scratch in 111 lines]]

*** Parsers

Firstly, let's cover what a parser is. In simple words, parser is:
1. A callable object (usually a function)
2. The types signature of which would be something along the lines o[fn:haskell-types]f

   #+BEGIN_SRC haskell
parser :: String -> Either SomeStructure ParsingError
   #+END_SRC

   Essentially it takes in some string data (or a stream of bytes or whatever
   else you choose to represent your text in) and spits out either a structure
   build from that text or an error if it fails to parse it.

So the key concept here is that a parser can *fail* or it can return a parsed
object that you are after alongside whatever else it didn't parse.
To clarify that last bit, often parsers return not only the structure that they
parse, but also the rest of the input that was left after they extracted that
structure.

For example if our parser =alphanumeric1= is able to parse a arbitrary length
alphanumeric string of length 1 or more, and then we apply it to a string we
might get something along the lines of the following:

#+BEGIN_SRC haskell
alphanumeric1 :: String -> Either (RestOfInput, ParsedStructure) ParsingError
alphanumeric1 = ...

inputString = "Hello how are you doing?"

alphanumeric inputString
-- Output: Left (" how are you doing?", "Hello")
-- Note: our parser in this example doesn't handle spaces
#+END_SRC

Other common parsers could be something along the lines of =multispace0= which
could parse 0 or more of anything that we consider as a space (tabs, newline,
regular spaces). Or a parser that parses a specific =tag= of our choice for
example ={= or =}=.

Thats neat, but on its own these parsers are very small and useless. This is
where the concepts of _parser combinators_ come into play.

*** Parser combinators

Firstly, lets set out the scene where we will use combinators and then it will
be easier to explain what they are and why we need them but in short a
combinator is a way to combine multiple parsers into a larger parser.

Also let us move away from Haskell and its beautifully clean syntax and start
looking at Rust which is what I used to implement my small scripting language.

Now for our case lets first check out the syntax for the language I was
implementing.

#+BEGIN_SRC
c: seq = {
    color ff0000;
    wait 1;
    blink 2 1 ff0000;
    wait 1;
    color 0000ff;
};
a: act = color 00ff00;
trigger c;
trigger a;
#+END_SRC

Without going into detail, I wanted to have the following:
1. a set of actions that the lights could perform - blink, change color, wait etc.
2. a way to store sequences of actions - the =c: seq=
3. a way to store single actions - the =a: act=
4. a way trigger these stored actions

Now perhaps its not the most comprehensive and turing complete language, but it
served its purpose of being a lighthearted application for learning how to do
parser combinators.

Back to our parsers! Firstly lets explore how I parse a single command e.g.
=color ff0000;=. Deconstructing its constituent parts we get:
- the word: =color=
- followed by one of more spaces
- a color string which is the main bit we want
- followed by a colon
- followed by optional newline or spaces

[[https://crates.io/crates/nom][nom]] - a Rust library that provides speedy parser combinators has quite a few
parsers already implemented. The =tag= parser can be used to parse the word
'color', the =hex_digit1= parser will help us deal with a string of hex values
for our color string, =space1= will help us parse 1 or more spaces and finally
we'll use =tag= again to deal with the colon. We will skip the newline for now.

Lets look at how the simplified parser implementation for color looks like and
decompose it into both the parsers we described above and the combinators we use.

#+BEGIN_SRC rust
fn color(i: &str) -> IResult<&str, &str> {
    let identifier = preceded(tag("color"), space1);
    let color_string = preceded(identifier, hex_digit1);
    let semicolon = terminated(tag(";"), multispace0);
   
    terminated(color_string, semicolon)(i)
}
#+END_SRC

Firstly, the input to the function is a string and the output is a type of
=Result=. A Result type in Rust basically tells you - something can return a
value or a failure state. And actually coming back to the Haskell snippets
mentioned previously - =IResult<&str, &str>= is equivilent to =Either (String,
String) Error=. The type signature out of the way, we move onto the actual body
of the function.

Lets first look at the =terminated= and =preceded= parser combinators. The ones
we see here are very similar and are basically inverted versions of each other.
The =preceded= combinator takes in two parsers and _combines_ them into one
parser where the the second parser is *preceeded* by the first one. Using this
knowledge we can now see that =identifier= is a parser that will return 1 or
more spaces only if they were preceeded by the word color.

To clarify, this parser will return a parsed input of 1 or more spaces only if
its preceeding parser =tag("color")= *_succeeds_*. Note that we're not really
interested in parsing the spaces themselves and what we're really trying to do
is to make a parser that fail when the pattern we are looking for isn't there
and its results are irrelevant to us in this case. So if one of the parsers
within the combinator fails, the whole combined parser fails.

Moving onto the =color_string= parser we can see it is quite similar. However
notice that now we are saying - get me a string of hexidecimal digits of length
1 or more that are preceeded by the =identifier=. So this parser first looks for
spaces preceeded by the word color and if that succeeds, it will look for the
hex string for the color. In contrast to the previous parser where we really
didn't care for the output of the parser (the 1 or more spaces), we actually
want the color output from this parser if it succeeds. Finally the =semicolon=
parser is a parser that takes the tag parser for the semicolon and then only
returns a result if the =multispace0= finds 0 or more space-like string after
the semicolon (hello optional newline!). Bus similarly to before, we aren't
interested in the semicolon itself, we will use this parser succeeding as an
indicator that something is followed by a semicolor and optional spaces.

Lastly we move onto the last combinator. Here we use the =color_string= parser
which will give us the string value of the color and say that it has to be
followed by a successful parsing of the semicolor parser. Also not that we're
finally passing the input string to this parser - =(i)= and returning the result
(in Rust no colon in the last statement of a function returns that value).


So in summary, we built a bunch of smaller parsers for which we mostly didn't
care if they returned some parsed value and we just cared if they succeeded in
matching bits of the string that they are designed to do. Then we build a
parsers that actually got us what we wanted, namely the hex string and then we
build a larger parser by combining these smaller bits.


We could extract the constituent parsers into their own functions and reuse
them! We can also test these smaller parsers individually to ensure quality.
Furthermore there are tons of other useful combintors for example =many1= which
basically takes a parser and keeps trying to reuse this parser until it fails
and return the results in a vector. So if you had multiple commands in a new
line and you wrote a generic command parser, you could use this many combinator
to suddenly be able to parse =n= number of these commands. Ultimately the whole
parser for my language and all of its bits and bobs turned out to look like
this:

#+BEGIN_SRC rust
/// Root parser for whole documents
pub fn root(i: &str) -> IResult<&str, Entities> {
    all_consuming(many0(terminated(
        alt((trigger, sequence, action)),
        many0(newline),
    )))(i)
}
#+END_SRC

Lets briefly run through this! So firstly we have the =all_consuming= combinator
which fails the whole parsing process if there are bits of the input left over
that haven't been parsed (meaning we're missing the ability to parse something).

Then we have have a =many0= (again very similar to like regex quantifiers) which
looks for a =many0(newline)= terminated lines containing one of the following
parsers (the =alt= parser is basically an =one of= across parsers):
- =trigger= - the trigger statement parser
- =sequence= - the parser to parse the sequence structure
- =action= - a standalone assigned action

So in the end it will return this =Entities= type, which I won't go into but it
is a collection of outputs from this parser all stacked together in a vector.
Which then my interpreter can deal with by looking at what each entity is
(statement, sequence assignment, action assignment).

*** Conclusion

Hopefully my write up of this inspires the more curious people to try this out
for themselves. In general writting a scripting language like this was quite a
fun experience. Ultimately I think what I enjoyed from this project is the
process of being aware of a technology and then finding a good use case to
practice this tech in some form of fun but educational project.


* Footnotes

[fn:haskell-types] For demonstration purposes I use haskell as its a very clean
looking language to start with. Later I will move onto Rust, but the same
concepts translate.

[fn:lighthouse] I had written a simple API wrapper and CLI for Philips Hue
lights that this scripting language uses. See more: https://github.com/finnkauski/lighthouse

[fn:markdown] I wrote this blog in org-mode markdown and then there was some
intermediary process that converted it to html. This is the type of stuff pandoc
is really good at.

[fn:1] Well, that's not really true as I stole this guideline from Mr. Hettingers talk.
